[{"path":"https://rjdemetra.github.io/rjd3filters/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jean Palate. Author, maintainer. Alain Quartier-la-Tente. Author.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Palate J, Quartier-la-Tente (2024). rjd3filters: Trend-Cycle Extraction Linear Filters. R package version 2.0.1, https://rjdemetra.github.io/rjd3filters/, https://github.com/rjdemetra/rjd3filters.","code":"@Manual{,   title = {rjd3filters: Trend-Cycle Extraction with Linear Filters},   author = {Jean Palate and Alain Quartier-la-Tente},   year = {2024},   note = {R package version 2.0.1, https://rjdemetra.github.io/rjd3filters/},   url = {https://github.com/rjdemetra/rjd3filters}, }"},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"rjd3filters","dir":"","previous_headings":"","what":"Trend-Cycle Extraction with Linear Filters","title":"Trend-Cycle Extraction with Linear Filters","text":"rjd3filters R package linear filters real-time trend-cycle estimates. allows create symmetric asymmetric moving averages : local polynomial filters, defined Proietti Luati (2008); FST approach Grun-Rehomme, Guggemos, Ladiray (2018), based optimization three criteria Fidelity, Smoothness Timeliness; Reproducing Kernel Hilbert Space (RKHS) Dagum Bianconcini (2008). quality criteria defined Wildi McElroy (2019) can also computed.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Trend-Cycle Extraction with Linear Filters","text":"rjd3filters relies rJava package Java SE 17 later version required. get current stable version (latest release): get current development version GitHub:","code":"# install.packages(\"remotes\") remotes::install_github(\"rjdemetra/rjd3toolkit@*release\") remotes::install_github(\"rjdemetra/rjd3filters@*release\") # install.packages(\"remotes\") # Install development version from GitHub remotes::install_github(\"rjdemetra/rjd3toolkit\") remotes::install_github(\"rjdemetra/rjd3filters\")"},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"basic-example","dir":"","previous_headings":"","what":"Basic example","title":"Trend-Cycle Extraction with Linear Filters","text":"example use symmetric moving average (Henderson), use three different methods compute asymmetric filters. consequence, filtered time series , except boundaries.  last estimates can also analysed implicit_forecast function retreive implicit forecasts corresponding asymmetric filters (.e., forecasts needed end-points estimates using symmetric filter).  real-time estimates (future points available) can also compared:","code":"library(\"rjd3filters\")  y <- window(retailsa$AllOtherGenMerchandiseStores, start = 2000) musgrave <- lp_filter(horizon = 6, kernel = \"Henderson\", endpoints = \"LC\")  # we put a large weight on the timeliness criteria fst_notimeliness_filter <- lapply(0:6, fst_filter,                                    lags = 6, smoothness.weight = 1/1000,                                    timeliness.weight = 1-1/1000, pdegree =2) fst_notimeliness <- finite_filters(sfilter = fst_notimeliness_filter[[7]],                                     rfilters = fst_notimeliness_filter[-7],                                     first_to_last = TRUE) # RKHS filters minimizing timeliness rkhs_timeliness <- rkhs_filter(horizon = 6, asymmetricCriterion = \"Timeliness\")  trend_musgrave <- filter(y, musgrave) trend_fst <- filter(y, fst_notimeliness) trend_rkhs <- filter(y, rkhs_timeliness) plot(ts.union(y, trend_musgrave, trend_fst, trend_rkhs), plot.type = \"single\",       col = c(\"black\", \"orange\", \"lightblue\", \"red\"),       main = \"Filtered time series\", ylab=NULL) legend(\"topleft\", legend = c(\"y\", \"Musgrave\", \"FST\", \"RKHS\"),         col= c(\"black\", \"orange\", \"lightblue\", \"red\"), lty = 1) f_musgrave <- implicit_forecast(y, musgrave) f_fst <- implicit_forecast(y, fst_notimeliness) f_rkhs <- implicit_forecast(y, rkhs_timeliness)  plot(window(y, start = 2007),       xlim = c(2007, 2012), ylim = c(3600, 4600),       main = \"Last estimates and implicit forecast\", ylab=NULL) lines(trend_musgrave,        col = \"orange\") lines(trend_fst,        col = \"lightblue\") lines(trend_rkhs,        col = \"red\") lines(ts(c(tail(y, 1), f_musgrave), frequency = frequency(y), start = end(y)),        col = \"orange\", lty = 2) lines(ts(c(tail(y, 1), f_fst), frequency = frequency(y), start = end(y)),        col = \"lightblue\", lty = 2) lines(ts(c(tail(y, 1), f_rkhs), frequency = frequency(y), start = end(y)),        col = \"red\", lty = 2) legend(\"topleft\", legend = c(\"y\", \"Musgrave\", \"FST\", \"RKHS\", \"Forecasts\"),         col= c(\"black\", \"orange\", \"lightblue\", \"red\", \"black\"),         lty = c(1, 1, 1, 1, 2)) trend_henderson<- filter(y, musgrave[, \"q=6\"]) trend_musgrave_q0 <- filter(y, musgrave[, \"q=0\"]) trend_fst_q0 <- filter(y, fst_notimeliness[, \"q=0\"]) trend_rkhs_q0 <- filter(y, rkhs_timeliness[, \"q=0\"]) plot(window(ts.union(y, trend_musgrave_q0, trend_fst_q0, trend_rkhs_q0),              start = 2007),       plot.type = \"single\",       col = c(\"black\", \"orange\", \"lightblue\", \"red\"),       main = \"Real time estimates of the trend\", ylab=NULL) legend(\"topleft\", legend = c(\"y\", \"Musgrave\", \"FST\", \"RKHS\"),         col= c(\"black\", \"orange\", \"lightblue\", \"red\"), lty = 1)"},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"comparison-of-the-filters","dir":"","previous_headings":"Basic example","what":"Comparison of the filters","title":"Trend-Cycle Extraction with Linear Filters","text":"Different quality criteria Grun-Rehomme et al (2018) Wildi McElroy(2019) can also computed function diagnostic_matrix(): filters can also compared plotting coefficients (plot_coef), gain function (plot_gain) phase function (plot_phase):","code":"q_0_coefs <- list(Musgrave = musgrave[, \"q=0\"],                    fst_notimeliness = fst_notimeliness[, \"q=0\"],                    rkhs_timeliness = rkhs_timeliness[, \"q=0\"])  sapply(q_0_coefs, diagnostic_matrix,         lags = 6, sweight = musgrave[, \"q=6\"]) #>         Musgrave fst_notimeliness rkhs_timeliness #> b_c  0.000000000     2.220446e-16     0.000000000 #> b_l -0.575984377    -1.554312e-15    -0.611459167 #> b_q -1.144593858     1.554312e-15     0.027626749 #> F_g  0.357509832     9.587810e-01     0.381135700 #> S_g  1.137610871     2.402400e+00     1.207752284 #> T_g  0.034088260     4.676398e-04     0.023197411 #> A_w  0.008306348     1.823745e-02     0.003677964 #> S_w  0.449956378     3.575634e+00     0.628156109 #> T_w  0.061789932     7.940547e-04     0.043540181 #> R_w  0.299548665     1.721377e-01     0.219948644 def.par <- par(no.readonly = TRUE) par(mai = c(0.3, 0.3, 0.2, 0)) layout(matrix(c(1, 1, 2, 3), 2, 2, byrow = TRUE))  plot_coef(fst_notimeliness, q = 0, col = \"lightblue\") plot_coef(musgrave, q = 0, add = TRUE, col = \"orange\") plot_coef(rkhs_timeliness, q = 0, add = TRUE, col = \"red\") legend(\"topleft\", legend = c(\"Musgrave\", \"FST\", \"RKHS\"),         col= c(\"orange\", \"lightblue\", \"red\"), lty = 1)  plot_gain(fst_notimeliness, q = 0, col = \"lightblue\") plot_gain(musgrave, q = 0, col = \"orange\", add = TRUE) plot_gain(rkhs_timeliness, q = 0, add = TRUE, col = \"red\") legend(\"topright\", legend = c(\"Musgrave\", \"FST\", \"RKHS\"),         col= c(\"orange\", \"lightblue\", \"red\"), lty = 1)  plot_phase(fst_notimeliness, q = 0, col = \"lightblue\") plot_phase(musgrave, q = 0, col = \"orange\", add = TRUE) plot_phase(rkhs_timeliness, q = 0, add = TRUE, col = \"red\") legend(\"topright\", legend = c(\"Musgrave\", \"FST\", \"RKHS\"),         col= c(\"orange\", \"lightblue\", \"red\"), lty = 1) par(def.par)"},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"manipulate-moving-averages","dir":"","previous_headings":"Basic example","what":"Manipulate moving averages","title":"Trend-Cycle Extraction with Linear Filters","text":"can also create manipulate moving averages class moving_average. next examples show create M2X12 moving average, first moving average used extract trend-cycle X-11, M3X3 moving average, applied months extract seasonal component.","code":"e1 <- moving_average(rep(1, 12), lags = -6) e1 <- e1/sum(e1) e2 <- moving_average(rep(1/12, 12), lags = -5) M2X12 <- (e1 + e2)/2 coef(M2X12) #>        t-6        t-5        t-4        t-3        t-2        t-1          t  #> 0.04166667 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333  #>        t+1        t+2        t+3        t+4        t+5        t+6  #> 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 0.04166667 M3 <- moving_average(rep(1/3, 3), lags = -1) M3X3 <- M3 * M3 # M3X3 moving average applied to each month M3X3 #> [1] \"0.1111 B^2 + 0.2222 B + 0.3333 + 0.2222 F + 0.1111 F^2\" M3X3_seasonal <- to_seasonal(M3X3, 12) # M3X3_seasonal moving average applied to the global series M3X3_seasonal #> [1] \"0.1111 B^24 + 0.2222 B^12 + 0.3333 + 0.2222 F^12 + 0.1111 F^24\"  def.par <- par(no.readonly = TRUE) par(mai = c(0.5, 0.8, 0.3, 0)) layout(matrix(c(1, 2), nrow = 1)) plot_gain(M3X3, main = \"M3X3 applied to each month\") plot_gain(M3X3_seasonal, main = \"M3X3 applied to the global series\") par(def.par)  # To apply the moving average t <- y * M2X12 si <- y - t s <- si * M3X3_seasonal # or equivalently: s_mm <- M3X3_seasonal * (1 - M2X12) s <- y * s_mm"},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"manipulate-finite-filters","dir":"","previous_headings":"Basic example","what":"Manipulate finite filters","title":"Trend-Cycle Extraction with Linear Filters","text":"finite_filters object combination central filter (used final estimates) different asymmetric filters used intermediate estimates beginning/end series central filter applied.","code":"musgrave  #>             q=6          q=5          q=4          q=3          q=2 #> t-6 -0.01934985 -0.016609040 -0.011623676 -0.009152423 -0.016139228 #> t-5 -0.02786378 -0.025914479 -0.022541271 -0.020981640 -0.024948087 #> t-4  0.00000000  0.001157790  0.002918842  0.003566851  0.002620762 #> t-3  0.06549178  0.065858066  0.066006963  0.065743350  0.067817618 #> t-2  0.14735651  0.146931288  0.145468029  0.144292794  0.149387420 #> t-1  0.21433675  0.213120014  0.210044599  0.207957742  0.216072726 #> t    0.24005716  0.238048915  0.233361346  0.230362866  0.241498208 #> t+1  0.21433675  0.211536998  0.205237273  0.201327171  0.215482871 #> t+2  0.14735651  0.143765257  0.135853376  0.131031652  0.148207710 #> t+3  0.06549178  0.061109020  0.051584983  0.045851637  0.000000000 #> t+4  0.00000000 -0.005174272 -0.016310464  0.000000000  0.000000000 #> t+5 -0.02786378 -0.033829557  0.000000000  0.000000000  0.000000000 #> t+6 -0.01934985  0.000000000  0.000000000  0.000000000  0.000000000 #>              q=1         q=0 #> t-6 -0.037925830 -0.07371504 #> t-5 -0.035216813 -0.04601336 #> t-4  0.003869912  0.01806602 #> t-3  0.080584644  0.11977342 #> t-2  0.173672322  0.23785375 #> t-1  0.251875504  0.34104960 #> t    0.288818862  0.40298562 #> t+1  0.274321400  0.00000000 #> t+2  0.000000000  0.00000000 #> t+3  0.000000000  0.00000000 #> t+4  0.000000000  0.00000000 #> t+5  0.000000000  0.00000000 #> t+6  0.000000000  0.00000000 musgrave * M3X3 #>              q=6          q=5          q=4           q=3          q=2 #> t-8 -0.002149983 -0.001845449 -0.001291520 -0.0010169359 -0.001793248 #> t-7 -0.007395941 -0.006570284 -0.005087625 -0.0043651651 -0.006358505 #> t-6 -0.012641899 -0.011166476 -0.008559414 -0.0073170774 -0.010632566 #> t-5 -0.006311026 -0.004754208 -0.002114058 -0.0009303015 -0.003784842 #> t-4  0.022584742  0.023742532  0.025503585  0.0261515939  0.025205505 #> t-3  0.075295705  0.075661988  0.075810884  0.0755472713  0.077621540 #> t-2  0.137975973  0.137550748  0.136087489  0.1349122536  0.140006880 #> t-1  0.188629568  0.187412835  0.184337420  0.1822505629  0.190365547 #> t    0.208025720  0.206017479  0.201329910  0.1983314300  0.209466772 #> t+1  0.188629568  0.185829819  0.179530094  0.1756199919  0.182437019 #> t+2  0.137975973  0.134384717  0.126472836  0.1242017153  0.124120786 #> t+3  0.075295705  0.070912941  0.066564227  0.0667717095  0.056877588 #> t+4  0.022584742  0.020311263  0.021121328  0.0247483251  0.016467523 #> t+5 -0.006311026 -0.005636466  0.002107117  0.0050946263  0.000000000 #> t+6 -0.012641899 -0.008092598 -0.001812274  0.0000000000  0.000000000 #> t+7 -0.007395941 -0.003758840  0.000000000  0.0000000000  0.000000000 #> t+8 -0.002149983  0.000000000  0.000000000  0.0000000000  0.000000000 #>              q=1         q=0 #> t-8 -0.004213981 -0.00819056 #> t-7 -0.012340941 -0.02149372 #> t-6 -0.020037912 -0.03278954 #> t-5 -0.010353070 -0.01439608 #> t-4  0.026454654  0.04065076 #> t-3  0.090388566  0.12957734 #> t-2  0.164291782  0.22847321 #> t-1  0.226168325  0.26940011 #> t    0.232502524  0.23654553 #> t+1  0.183608603  0.12744676 #> t+2  0.093051296  0.04477618 #> t+3  0.030480156  0.00000000 #> t+4  0.000000000  0.00000000 #> t+5  0.000000000  0.00000000 #> t+6  0.000000000  0.00000000 #> t+7  0.000000000  0.00000000 #> t+8  0.000000000  0.00000000"},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"bibliography","dir":"","previous_headings":"","what":"Bibliography","title":"Trend-Cycle Extraction with Linear Filters","text":"Dagum, Estela Bee Silvia Bianconcini (2008). “Henderson Smoother Reproducing Kernel Hilbert Space”. : Journal Business & Economic Statistics 26, pp. 536–545. URL: https://ideas.repec.org//bes/jnlbes/v26y2008p536-545.html. Grun-Rehomme, Michel, Fabien Guggemos, Dominique Ladiray (2018). “Asymmetric Moving Averages Minimizing Phase Shift”. : Handbook Seasonal Adjustment. URL: https://ec.europa.eu/eurostat/web/products-manuals--guidelines/-/KS-GQ-18-001. Proietti, Tommaso Alessandra Luati (Dec. 2008). “Real time estimation local polynomial regression, application trend-cycle analysis”. : Ann. Appl. Stat. 2.4, pp. 1523–1553. URL: https://doi.org/10.1214/08-AOAS195. Wildi, Marc Tucker McElroy (2019). “trilemma accuracy, timeliness smoothness real-time signal extraction”. : International Journal Forecasting 35.3, pp. 1072–1084. URL: https://EconPapers.repec.org/RePEc:eee:intfor:v:35:y:2019::3:p:1072-1084.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Trend-Cycle Extraction with Linear Filters","text":"contribution welcome done pull requests /issues.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/index.html","id":"licensing","dir":"","previous_headings":"","what":"Licensing","title":"Trend-Cycle Extraction with Linear Filters","text":"code project licensed European Union Public Licence (EUPL).","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/cross_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation — cross_validation","title":"Cross-Validation — cross_validation","text":"Computes cross-validation statistic moving-average time series","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/cross_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation — cross_validation","text":"","code":"cross_validation(x, coef, ...)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/cross_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation — cross_validation","text":"x input time series. coef vector coefficients moving-average (moving_average()). ... arguments passed function moving_average() convert coef \"moving_average\" object.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/cross_validation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross-Validation — cross_validation","text":"cross-validation statistics moving average \\((\\theta_i)_{-p\\leq \\leq p}\\) time series \\((y_i)_{1\\leq \\leq n}\\) : $$ \\frac{1}{n-(p+q)} \\sum_{t=p+1}^{n-q} \\left( \\frac{y_t - \\sum_{=-p}^q \\theta_i y_{t+}}{ 1-\\theta_0 } \\right)^2. $$ function cross_validation() returns time series \\((x_t)\\)) $$ x_t = \\frac{y_t - \\sum_{=-p}^q \\theta_i y_{t+}}{ 1-\\theta_0 }. $$","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/dfa_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Direct Filter Approach — dfa_filter","title":"Direct Filter Approach — dfa_filter","text":"Direct Filter Approach","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/dfa_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Direct Filter Approach — dfa_filter","text":"","code":"dfa_filter(   horizon = 6,   degree = 0,   density = c(\"uniform\", \"rw\"),   targetfilter = lp_filter(horizon = horizon)[, 1],   passband = 2 * pi/12,   accuracy.weight = 1/3,   smoothness.weight = 1/3,   timeliness.weight = 1/3 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/dfa_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Direct Filter Approach — dfa_filter","text":"horizon horizon (bandwidth) symmetric filter. degree degree polynomial. density hypothesis spectral density: \"uniform\" (= white woise, default)  \"rw\" (= random walk). targetfilter weights symmetric target filters (default Henderson filter). passband passband threshold. accuracy.weight, smoothness.weight, timeliness.weight weight used optimisation. weight associated residual derived sum four weights equal 1.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/dfa_filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Direct Filter Approach — dfa_filter","text":"Moving average computed minimisation weighted mean three criteria polynomials constraints. criteria come decomposition mean squared error th trend-cycle Let \\(\\boldsymbol \\theta=(\\theta_{-p},\\dots,\\theta_{f})'\\) moving average \\(p\\) \\(f\\) two integers defined parameter lags leads. three criteria :","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/dfa_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Direct Filter Approach — dfa_filter","text":"","code":"dfa_filter(horizon = 6, degree = 0) #>             q=6          q=5           q=4         q=3         q=2         q=1 #> t-6 -0.01934985 -0.030012305 -0.0408092039 -0.04068978 -0.03622977 -0.03672904 #> t-5 -0.02786378 -0.033359743 -0.0411977083 -0.04106306 -0.03072500 -0.01681858 #> t-4  0.00000000  0.001617955  0.0031630124  0.00320233  0.01204228  0.04093710 #> t-3  0.06549178  0.071870402  0.0795170526  0.07941604  0.08550769  0.12220301 #> t-2  0.14735651  0.154367848  0.1632402190  0.16312197  0.16726498  0.20144314 #> t-1  0.21433675  0.218278871  0.2226926829  0.22264487  0.22680122  0.25014591 #> t    0.24005716  0.238829368  0.2358094694  0.23588451  0.24196319  0.24750757 #> t+1  0.21433675  0.207944469  0.1985282507  0.19868118  0.20515234  0.19131090 #> t+2  0.14735651  0.138054450  0.1272631817  0.12741087  0.12822306  0.00000000 #> t+3  0.06549178  0.057433857  0.0513680901  0.05139107  0.00000000  0.00000000 #> t+4  0.00000000 -0.002016302  0.0004249535  0.00000000  0.00000000  0.00000000 #> t+5 -0.02786378 -0.023008869  0.0000000000  0.00000000  0.00000000  0.00000000 #> t+6 -0.01934985  0.000000000  0.0000000000  0.00000000  0.00000000  0.00000000 #>             q=0 #> t-6 -0.02675707 #> t-5  0.01420277 #> t-4  0.08880802 #> t-3  0.17595533 #> t-2  0.24508791 #> t-1  0.26838604 #> t    0.23431701 #> t+1  0.00000000 #> t+2  0.00000000 #> t+3  0.00000000 #> t+4  0.00000000 #> t+5  0.00000000 #> t+6  0.00000000 dfa_filter(horizon = 6, degree = 2) #>             q=6          q=5         q=4         q=3         q=2          q=1 #> t-6 -0.01934985 -0.031105441 -0.04888338 -0.05764640 -0.04948784 -0.007961043 #> t-5 -0.02786378 -0.030840929 -0.03722806 -0.04096008 -0.03686433 -0.036884447 #> t-4  0.00000000  0.005553125  0.01509948  0.02043095  0.01419427 -0.019710732 #> t-3  0.06549178  0.075680118  0.09443554  0.10664294  0.09370622  0.043998864 #> t-2  0.14735651  0.157683962  0.17753428  0.18829824  0.17738803  0.138819404 #> t-1  0.21433675  0.221376079  0.23306525  0.23716685  0.23398281  0.237104542 #> t    0.24005716  0.241802252  0.23989975  0.23478728  0.24355756  0.308924895 #> t+1  0.21433675  0.210178737  0.19487115  0.18311315  0.20164062  0.335708518 #> t+2  0.14735651  0.138186344  0.11635204  0.10287717  0.12188266  0.000000000 #> t+3  0.06549178  0.054026865  0.03459332  0.02528989  0.00000000  0.000000000 #> t+4  0.00000000 -0.009233115 -0.01973936  0.00000000  0.00000000  0.000000000 #> t+5 -0.02786378 -0.033307998  0.00000000  0.00000000  0.00000000  0.000000000 #> t+6 -0.01934985  0.000000000  0.00000000  0.00000000  0.00000000  0.000000000 #>             q=0 #> t-6  0.13737578 #> t-5 -0.08485848 #> t-4 -0.16654786 #> t-3 -0.10200794 #> t-2  0.09325916 #> t-1  0.38573469 #> t    0.73704465 #> t+1  0.00000000 #> t+2  0.00000000 #> t+3  0.00000000 #> t+4  0.00000000 #> t+5  0.00000000 #> t+6  0.00000000"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/diagnostic_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute quality criteria for asymmetric filters — diagnostic_matrix","title":"Compute quality criteria for asymmetric filters — diagnostic_matrix","text":"Function du compute diagnostic matrix quality criteria asymmetric filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/diagnostic_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute quality criteria for asymmetric filters — diagnostic_matrix","text":"","code":"diagnostic_matrix(x, lags, passband = pi/6, sweights, ...)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/diagnostic_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute quality criteria for asymmetric filters — diagnostic_matrix","text":"x Weights asymmetric filter (-lags m). lags Lags filter (positive). passband passband threshold. sweights Weights symmetric filter (0 lags -lags lags). missing, criteria functions mse computed. ... optional arguments mse.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/diagnostic_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute quality criteria for asymmetric filters — diagnostic_matrix","text":"moving average coefficients \\(\\theta=(\\theta_i)_{-p\\le \\le q}\\) diagnostic_matrix returns list following ten criteria: b_c  Constant bias (\\(b_c=0\\), \\(\\theta\\) preserve constant trends) $$\\sum_{=-p}^q\\theta_i - 1$$ b_l  Linear bias  (\\(b_c=b_l=0\\), \\(\\theta\\) preserve constant trends) $$\\sum_{=-p}^q \\theta_i$$ b_q  Quadratic bias  (\\(b_c=b_l=b_q=0\\), \\(\\theta\\) preserve quadratic trends) $$\\sum_{=-p}^q ^2 \\theta_i$$ F_g  Fidelity criterium Grun-Rehomme et al (2018) $$$$ S_g  Smoothness criterium Grun-Rehomme et al (2018) T_g  Timeliness criterium Grun-Rehomme et al (2018) A_w  Accuracy criterium Wildi McElroy (2019) S_w  Smoothness criterium Wildi McElroy (2019) T_w  Timeliness criterium Wildi McElroy (2019) R_w  Residual criterium Wildi McElroy (2019)","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/diagnostic_matrix.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute quality criteria for asymmetric filters — diagnostic_matrix","text":"Grun-Rehomme, Michel, Fabien Guggemos, Dominique Ladiray (2018). “Asymmetric Moving Averages Minimizing Phase Shift”. : Handbook Seasonal Adjustment. Wildi, Marc McElroy, Tucker (2019). “trilemma accuracy, timeliness smoothness real-time signal extraction”. : International Journal Forecasting 35.3, pp. 1072–1084.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear Filtering on a Time Series — filter","title":"Linear Filtering on a Time Series — filter","text":"Applies linear filtering univariate time series series separately multivariate time series using either moving average (symmetric asymmetric) combination symmetric moving average center asymmetric moving averages bounds.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear Filtering on a Time Series — filter","text":"","code":"filter(x, coefs, remove_missing = TRUE)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear Filtering on a Time Series — filter","text":"x univariate multivariate time series. coefs matrix list contains coefficients asymmetric symmetric filters. (symmetric filter shortest). See details. remove_missing TRUE (default) leading trailing NA removed filtering.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Linear Filtering on a Time Series — filter","text":"functions filter extends filter allowing apply every kind moving averages (symmetric asymmetric filters) apply aset multiple moving averages deal boundaries. Let \\(x_t\\) input time series filter. coef object moving_average(), length \\(q\\), result \\(y\\) equal time \\(t\\) : $$y[t] = x[t-lags] * coef[1] + x[t-lags+1] * coef[1] + ... + x[t-lags+q] * coef[q]$$. extends function filter add NA end time series. coef matrix, list finite_filters() object,  center, symmetric moving average used (first column/element coefs). boundaries, last moving average coefs used compute filtered time series \\(y[n]\\) (future point known), second last compute filtered time series \\(y[n-1]\\) (one future point known)...","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear Filtering on a Time Series — filter","text":"","code":"x <- retailsa$DrinkingPlaces  lags <- 6 leads <- 2 fst_coef <- fst_filter(lags = lags, leads = leads, smoothness.weight = 0.3, timeliness.weight = 0.3) lpp_coef <- lp_filter(horizon = lags, kernel = \"Henderson\", endpoints = \"LC\")  fst_ma <- filter(x, fst_coef) lpp_ma <- filter(x, lpp_coef[,\"q=2\"])  plot(ts.union(x, fst_ma, lpp_ma), plot.type = \"single\", col = c(\"black\",\"red\",\"blue\"))   trend <- filter(x, lpp_coef) # This is equivalent to: trend <- localpolynomials(x, horizon = 6)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filters_operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Operations on Filters — filters_operations","title":"Operations on Filters — filters_operations","text":"Manipulation moving_average() finite_filters() objects","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filters_operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Operations on Filters — filters_operations","text":"","code":"# S3 method for moving_average sum(..., na.rm = FALSE)  # S4 method for moving_average,numeric [(x, i)  # S4 method for moving_average,logical [(x, i)  # S4 method for moving_average,ANY,missing,numeric [(x, i) <- value  # S3 method for moving_average cbind(...)  # S3 method for moving_average rbind(...)  # S4 method for moving_average,moving_average +(e1, e2)  # S4 method for moving_average,numeric +(e1, e2)  # S4 method for numeric,moving_average +(e1, e2)  # S4 method for moving_average,missing +(e1, e2)  # S4 method for moving_average,missing -(e1, e2)  # S4 method for moving_average,moving_average -(e1, e2)  # S4 method for moving_average,numeric -(e1, e2)  # S4 method for numeric,moving_average -(e1, e2)  # S4 method for moving_average,moving_average *(e1, e2)  # S4 method for moving_average,numeric *(e1, e2)  # S4 method for numeric,moving_average *(e1, e2)  # S4 method for ANY,moving_average *(e1, e2)  # S4 method for moving_average,ANY *(e1, e2)  # S4 method for moving_average,numeric /(e1, e2)  # S4 method for moving_average,numeric ^(e1, e2)  # S4 method for finite_filters,moving_average *(e1, e2)  # S4 method for moving_average,finite_filters *(e1, e2)  # S4 method for finite_filters,numeric *(e1, e2)  # S4 method for ANY,finite_filters *(e1, e2)  # S4 method for finite_filters,ANY *(e1, e2)  # S4 method for numeric,finite_filters +(e1, e2)  # S4 method for finite_filters,moving_average +(e1, e2)  # S4 method for moving_average,finite_filters +(e1, e2)  # S4 method for finite_filters,missing +(e1, e2)  # S4 method for finite_filters,missing -(e1, e2)  # S4 method for finite_filters,moving_average -(e1, e2)  # S4 method for moving_average,finite_filters -(e1, e2)  # S4 method for finite_filters,numeric -(e1, e2)  # S4 method for numeric,finite_filters -(e1, e2)  # S4 method for finite_filters,numeric /(e1, e2)  # S4 method for finite_filters,numeric ^(e1, e2)  # S4 method for finite_filters,finite_filters *(e1, e2)  # S4 method for finite_filters,finite_filters +(e1, e2)  # S4 method for finite_filters,finite_filters -(e1, e2)  # S4 method for finite_filters,missing [(x, i, j, ..., drop = TRUE)  # S4 method for finite_filters,ANY [(x, i, j, ..., drop = TRUE)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/filters_operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Operations on Filters — filters_operations","text":"..., drop, na.rm parameters. x, e1, e2 object , j, value indices specifying elements extract replace new value","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/finite_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulating Finite Filters — finite_filters","title":"Manipulating Finite Filters — finite_filters","text":"Manipulating Finite Filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/finite_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulating Finite Filters — finite_filters","text":"","code":"finite_filters(   sfilter,   rfilters = NULL,   lfilters = NULL,   first_to_last = FALSE )  # S4 method for finite_filters show(object)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/finite_filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manipulating Finite Filters — finite_filters","text":"sfilter symmetric filter (moving_average() object) matrix list coefficients. rfilters right filters (used last points). lfilters left filters (used first points). first_to_last boolean indicating first element rfilters first asymmetric filter (one observation missing) last one (real-time estimates). object finite_filters object.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/finite_filters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manipulating Finite Filters — finite_filters","text":"","code":"ff_lp <- lp_filter() ff_simple_ma <- finite_filters(moving_average(c(1, 1, 1), lags = -1)/3,                rfilters = list(moving_average(c(1, 1), lags = -1)/2)) ff_lp #>             q=6          q=5          q=4          q=3          q=2 #> t-6 -0.01934985 -0.016609040 -0.011623676 -0.009152423 -0.016139228 #> t-5 -0.02786378 -0.025914479 -0.022541271 -0.020981640 -0.024948087 #> t-4  0.00000000  0.001157790  0.002918842  0.003566851  0.002620762 #> t-3  0.06549178  0.065858066  0.066006963  0.065743350  0.067817618 #> t-2  0.14735651  0.146931288  0.145468029  0.144292794  0.149387420 #> t-1  0.21433675  0.213120014  0.210044599  0.207957742  0.216072726 #> t    0.24005716  0.238048915  0.233361346  0.230362866  0.241498208 #> t+1  0.21433675  0.211536998  0.205237273  0.201327171  0.215482871 #> t+2  0.14735651  0.143765257  0.135853376  0.131031652  0.148207710 #> t+3  0.06549178  0.061109020  0.051584983  0.045851637  0.000000000 #> t+4  0.00000000 -0.005174272 -0.016310464  0.000000000  0.000000000 #> t+5 -0.02786378 -0.033829557  0.000000000  0.000000000  0.000000000 #> t+6 -0.01934985  0.000000000  0.000000000  0.000000000  0.000000000 #>              q=1         q=0 #> t-6 -0.037925830 -0.07371504 #> t-5 -0.035216813 -0.04601336 #> t-4  0.003869912  0.01806602 #> t-3  0.080584644  0.11977342 #> t-2  0.173672322  0.23785375 #> t-1  0.251875504  0.34104960 #> t    0.288818862  0.40298562 #> t+1  0.274321400  0.00000000 #> t+2  0.000000000  0.00000000 #> t+3  0.000000000  0.00000000 #> t+4  0.000000000  0.00000000 #> t+5  0.000000000  0.00000000 #> t+6  0.000000000  0.00000000 ff_simple_ma #>           q=1 q=0 #> t-1 0.3333333 0.5 #> t   0.3333333 0.5 #> t+1 0.3333333 0.0 ff_lp * ff_simple_ma #>              q=7          q=6          q=5          q=4          q=3 #> t-7 -0.006449948 -0.006449948 -0.005536347 -0.003874559 -0.003050808 #> t-6 -0.015737874 -0.015737874 -0.014174506 -0.011388316 -0.010044688 #> t-5 -0.015737874 -0.015737874 -0.013788576 -0.010415368 -0.008855737 #> t-4  0.012542669  0.012542669  0.013700459  0.015461511  0.016109520 #> t-3  0.070949432  0.070949432  0.071315715  0.071464612  0.071200998 #> t-2  0.142395015  0.142395015  0.141969789  0.140506531  0.139331295 #> t-1  0.200583472  0.200583472  0.199366739  0.196291325  0.194204467 #> t    0.222910217  0.222910217  0.220901976  0.216214406  0.213215926 #> t+1  0.200583472  0.200583472  0.197783724  0.191483998  0.187573896 #> t+2  0.142395015  0.142395015  0.138803758  0.130891877  0.133712093 #> t+3  0.070949432  0.070949432  0.066566668  0.054324221  0.066603036 #> t+4  0.012542669  0.012542669  0.001730137  0.009039762  0.000000000 #> t+5 -0.015737874 -0.018962848 -0.018639536  0.000000000  0.000000000 #> t+6 -0.015737874 -0.018962848  0.000000000  0.000000000  0.000000000 #> t+7 -0.006449948  0.000000000  0.000000000  0.000000000  0.000000000 #>              q=2         q=1         q=0 #> t-7 -0.005379743 -0.01264194 -0.02457168 #> t-6 -0.013695772 -0.02438088 -0.03990947 #> t-5 -0.012822184 -0.02309091 -0.03388746 #> t-4  0.015163431  0.01641258  0.03060869 #> t-3  0.073275267  0.08604229  0.12523106 #> t-2  0.144425922  0.16871082  0.23289226 #> t-1  0.202319451  0.23812223  0.39446059 #> t    0.224351268  0.31739216  0.31517601 #> t+1  0.226430881  0.23343365  0.00000000 #> t+2  0.145931478  0.00000000  0.00000000 #> t+3  0.000000000  0.00000000  0.00000000 #> t+4  0.000000000  0.00000000  0.00000000 #> t+5  0.000000000  0.00000000  0.00000000 #> t+6  0.000000000  0.00000000  0.00000000 #> t+7  0.000000000  0.00000000  0.00000000"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst.html","id":null,"dir":"Reference","previous_headings":"","what":"FST criteria — fst","title":"FST criteria — fst","text":"Compute Fidelity, Smoothness Timeliness (FST) criteria","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"FST criteria — fst","text":"","code":"fst(weights, lags, passband = pi/6, ...)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"FST criteria — fst","text":"weights either \"moving_average\" numeric vector containing weights. lags Lags moving average (weights \"moving_average\"). passband Passband threshold timeliness criterion. ... unused arguments.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"FST criteria — fst","text":"values 3 criteria, gain phase associated filter.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"FST criteria — fst","text":"Grun-Rehomme, Michel, Fabien Guggemos, Dominique Ladiray (2018). “Asymmetric Moving Averages Minimizing Phase Shift”. : Handbook Seasonal Adjustment, https://ec.europa.eu/eurostat/web/products-manuals--guidelines/-/ks-gq-18-001.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"FST criteria — fst","text":"","code":"filter <- lp_filter(horizon = 6, kernel = \"Henderson\", endpoints = \"LC\") fst(filter[, \"q=0\"]) #>   Fidelity Smoothness Timeliness  #> 0.35750983 1.13761087 0.03408826  # To compute the statistics on all filters: fst(filter) #>                      q=6          q=5          q=4          q=3          q=2 #> Fidelity    2.038158e-01 1.992842e-01 1.882514e-01 1.817971e-01 0.2012127809 #> Smoothness  8.335318e-03 1.718954e-02 2.053650e-02 9.763906e-03 0.0800330845 #> Timeliness -3.009266e-35 2.907314e-05 6.954826e-05 5.078351e-05 0.0003411454 #>                    q=1        q=0 #> Fidelity   0.261459364 0.35750983 #> Smoothness 0.413844949 1.13761087 #> Timeliness 0.005496608 0.03408826"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","title":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","text":"Estimation filter using Fidelity-Smoothness-Timeliness criteria","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","text":"","code":"fst_filter(   lags = 6,   leads = 0,   pdegree = 2,   smoothness.weight = 1,   smoothness.degree = 3,   timeliness.weight = 0,   timeliness.passband = pi/6,   timeliness.antiphase = TRUE )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","text":"lags Lags filter (positive). leads Leads filter (positive 0). pdegree Local polynomials preservation: max degree. smoothness.weight Weight smoothness criterion (\\([0, 1]\\)). smoothness.degree Degree smoothness criterion (3 Henderson). timeliness.weight Weight Timeliness criterion (\\([0, 1[\\)). sweight+tweight \\([0,1]\\). timeliness.passband Passband timeliness criterion (radians). phase effect computed \\([0, passband]\\). timeliness.antiphase boolean indicating timeliness computed analytically (TRUE) numerically (FALSE).","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst_filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","text":"Moving average computed minimisation weighted mean three criteria polynomials constraints. Let \\(\\boldsymbol \\theta=(\\theta_{-p},\\dots,\\theta_{f})'\\) moving average \\(p\\) \\(f\\) two integers defined parameter lags leads. three criteria : Fidelity, \\(F_g\\): variance reduction ratio. $$ F_g(\\boldsymbol \\theta) = \\sum_{k=-p}^{+f}\\theta_{k}^{2} $$ Smoothness, \\(S_g\\): measures flexibility coefficient curve filter smoothness trend. $$ S_g(\\boldsymbol \\theta) = \\sum_{j}(\\nabla^{q}\\theta_{j})^{2} $$ integer \\(q\\) defined parameter smoothness.degree. default, Henderson criteria used (smoothness.degree = 3). Timeliness, \\(T_g\\) : $$ T_g(\\boldsymbol\\theta)=\\int_{0}^{\\omega_{2}}f(\\rho_{\\boldsymbol\\theta}(\\omega),\\varphi_{\\boldsymbol\\theta}(\\omega))d\\omega $$ \\(\\rho_{\\boldsymbol\\theta}\\) \\(\\varphi_{\\boldsymbol\\theta}\\) gain phase shift functions \\(\\boldsymbol \\theta\\),  \\(f\\) penalty function defined \\(f\\colon(\\rho,\\varphi)\\mapsto\\rho^2\\sin(\\varphi)^2\\) analytically solvable criterium. \\(\\omega_{2}\\) defined parameter timeliness.passband default equal \\(2\\pi/12\\): monthly time series, focus timeliness associated cycles 12 months . moving average computed solving problem: $$ \\begin{cases} \\underset{\\theta}{\\min} & J(\\theta)=   (1-\\beta-\\gamma) F_g(\\theta)+\\beta S_g(\\theta)+\\gamma T_g(\\theta)\\\\ s.t. & C\\theta=\\end{cases} $$ \\(C\\theta=\\) represents linear constraints moving average preserve polynomials degree \\(q\\) (pdegree): $$ C=\\begin{pmatrix} 1 & \\cdots&1\\\\ -h & \\cdots&h \\\\ \\vdots & \\cdots & \\vdots \\\\ (-h)^d & \\cdots&h^d \\end{pmatrix},\\quad =\\begin{pmatrix} 1 \\\\0 \\\\ \\vdots\\\\0 \\end{pmatrix} $$","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst_filter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","text":"Grun-Rehomme, Michel, Fabien Guggemos, Dominique Ladiray (2018). “Asymmetric Moving Averages Minimizing Phase Shift”. : Handbook Seasonal Adjustment, https://ec.europa.eu/eurostat/web/products-manuals--guidelines/-/ks-gq-18-001.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/fst_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimation of a filter using the Fidelity-Smoothness-Timeliness criteria — fst_filter","text":"","code":"filter <- fst_filter(lags = 6, leads = 0) filter #> [1] \"0.1678 B^6 - 0.3147 B^4 - 0.2797 B^3 + 0.2098 B^2 + 0.6713 B + 0.5455\""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the coefficients of a kernel — get_kernel","title":"Get the coefficients of a kernel — get_kernel","text":"Function get coefficient associated kernel. coefficients used compute different filters.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the coefficients of a kernel — get_kernel","text":"","code":"get_kernel(   kernel = c(\"Henderson\", \"Uniform\", \"Triangular\", \"Epanechnikov\", \"Parabolic\",     \"BiWeight\", \"TriWeight\", \"Tricube\", \"Trapezoidal\", \"Gaussian\"),   horizon,   sd_gauss = 0.25 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the coefficients of a kernel — get_kernel","text":"kernel kernel uses. horizon horizon (bandwidth) symmetric filter. sd_gauss standard deviation gaussian kernel. default 0.25.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the coefficients of a kernel — get_kernel","text":"tskernel object (see kernel).","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_kernel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the coefficients of a kernel — get_kernel","text":"","code":"get_kernel(\"Henderson\", horizon = 3) #> henderson  #> coef[-3] = 0.04895 #> coef[-2] = 0.13054 #> coef[-1] = 0.20396 #> coef[ 0] = 0.23310 #> coef[ 1] = 0.20396 #> coef[ 2] = 0.13054 #> coef[ 3] = 0.04895"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_moving_average.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Moving Averages from ARIMA model — get_moving_average","title":"Get Moving Averages from ARIMA model — get_moving_average","text":"Get Moving Averages ARIMA model","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_moving_average.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Moving Averages from ARIMA model — get_moving_average","text":"","code":"get_moving_average(x, ...)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_moving_average.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Moving Averages from ARIMA model — get_moving_average","text":"x object. ... unused parameters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_moving_average.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Moving Averages from ARIMA model — get_moving_average","text":"","code":"fit <- stats::arima(log10(AirPassengers), c(0, 1, 1), seasonal = list(order = c(0, 1, 1), period = 12)) get_moving_average(fit) #> $left #> $left$ar #> [1] \"1.0000\" #>  #> $left$sar #> [1] \"1.0000\" #>  #> $left$diff #> [1] \" -  B + 1.0000\" #>  #> $left$sdiff #> [1] \" -  B^12 + 1.0000\" #>  #>  #> $right #> $right$ma #> [1] \" - 0.4018 B + 1.0000\" #>  #> $right$sma #> [1] \" - 0.5569 B^12 + 1.0000\" #>  #>"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_properties_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Get properties of filters — get_properties_function","title":"Get properties of filters — get_properties_function","text":"Get properties filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_properties_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get properties of filters — get_properties_function","text":"","code":"get_properties_function(   x,   component = c(\"Symmetric Gain\", \"Symmetric Phase\", \"Symmetric transfer\",     \"Asymmetric Gain\", \"Asymmetric Phase\", \"Asymmetric transfer\"),   ... )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_properties_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get properties of filters — get_properties_function","text":"x \"moving_average\" \"finite_filters\" object. component component extract. ... unused arguments.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/get_properties_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get properties of filters — get_properties_function","text":"","code":"filter <- lp_filter(3, kernel = \"Henderson\") sgain <- get_properties_function(filter, \"Symmetric Gain\") plot(sgain, xlim= c(0, pi/12))"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/implicit_forecast.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve implicit forecasts corresponding to the asymmetric filters — implicit_forecast","title":"Retrieve implicit forecasts corresponding to the asymmetric filters — implicit_forecast","text":"Function retrieve implicit forecasts corresponding asymmetric filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/implicit_forecast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve implicit forecasts corresponding to the asymmetric filters — implicit_forecast","text":"","code":"implicit_forecast(x, coefs)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/implicit_forecast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve implicit forecasts corresponding to the asymmetric filters — implicit_forecast","text":"x univariate multivariate time series. coefs matrix list contains coefficients asymmetric symmetric filters. (symmetric filter shortest). See details.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/implicit_forecast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Retrieve implicit forecasts corresponding to the asymmetric filters — implicit_forecast","text":"Let \\(h\\) bandwidth symmetric filter, \\(v_{-h}, \\ldots, v_h\\) coefficients symmetric filter \\(w_{-h}^q, \\ldots, w_h^q\\) coefficients asymmetric filter used estimate trend \\(q\\) future values known (convention \\(w_{q+1}^q=\\ldots=w_h^q=0\\)). Let denote \\(y_{-h},\\ldots, y_0\\) las \\(h\\) available values input times series. Let also note \\(y_{-h},\\ldots,y_{0}\\) observed series studied \\(y_{1}^*,\\dots y_h^*\\)implicit forecast induced \\(w^0,\\dots w^{h-1}\\). means : $$ \\forall q, \\quad \\sum_{=-h}^0 v_iy_i + \\sum_{=1}^h v_iy_i^* =\\sum_{=-h}^0 w_i^qy_i + \\sum_{=1}^h w_i^qy_i^* $$ equivalent $$ \\forall q, \\sum_{=1}^h (v_i- w_i^q) y_i^* =\\sum_{=-h}^0 (w_i^q-v_i)y_i. $$ Note solved numerically: solution exact.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/implicit_forecast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve implicit forecasts corresponding to the asymmetric filters — implicit_forecast","text":"","code":"x <- retailsa$AllOtherGenMerchandiseStores ql <- lp_filter(horizon = 6, kernel = \"Henderson\", endpoints = \"QL\") lc <- lp_filter(horizon = 6, kernel = \"Henderson\", endpoints = \"LC\") f_ql <- implicit_forecast(x, ql) f_lc <- implicit_forecast(x, lc)  plot(window(x, start = 2007),      xlim = c(2007,2012)) lines(ts(c(tail(x,1), f_ql), frequency = frequency(x), start = end(x)),       col = \"red\", lty = 2) lines(ts(c(tail(x,1), f_lc), frequency = frequency(x), start = end(x)),       col = \"blue\", lty = 2)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/impute_last_obs.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute Incomplete Finite Filters — impute_last_obs","title":"Impute Incomplete Finite Filters — impute_last_obs","text":"Impute Incomplete Finite Filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/impute_last_obs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute Incomplete Finite Filters — impute_last_obs","text":"","code":"impute_last_obs(x, n, nperiod = 1, backward = TRUE, forward = TRUE)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/impute_last_obs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute Incomplete Finite Filters — impute_last_obs","text":"x finite_filters() object. n integer specifying number imputed periods. default missing moving averages imputed. nperiod integer specifying imput missing date. nperiod = 1 means imputation using last filtered data (1 period backward), nperiod = 12 monthly data means imputation using last year filtered data, etc. backward, forward boolean indicating imputation done backward (left filters), forward (right filters).","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/impute_last_obs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impute Incomplete Finite Filters — impute_last_obs","text":"combining finite filters moving average, first /last points computed. example, using M2X12 moving average (symmetric moving average coefficients \\(\\theta = \\begin{pmatrix} 1/24 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/12 & 1/24 \\end{pmatrix}\\)), first last 6 points computed. impute_last_obs() allows impute first/last points using nperiod previous filtered data. nperiod = 1, last filtered data used imputation, nperiod = 12 monthly data, last year filtered data used imputation, etc.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/impute_last_obs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute Incomplete Finite Filters — impute_last_obs","text":"","code":"y <- window(retailsa$AllOtherGenMerchandiseStores, start = 2008) M3 <- moving_average(rep(1/3, 3), lags = -1) M3X3 <- M3 * M3 M2X12 <- (simple_ma(12, -6) + simple_ma(12, -5)) / 2 composite_ma <- M3X3 * M2X12 # The last 6 points cannot be computed composite_ma #> [1] \"0.0046 B^8 + 0.0185 B^7 + 0.0417 B^6 + 0.0648 B^5 + 0.0787 B^4 + 0.0833 B^3 + 0.0833 B^2 + 0.0833 B + 0.0833 + 0.0833 F + 0.0833 F^2 + 0.0833 F^3 + 0.0787 F^4 + 0.0648 F^5 + 0.0417 F^6 + 0.0185 F^7 + 0.0046 F^8\" composite_ma * y #>           Jan      Feb      Mar      Apr      May      Jun      Jul      Aug #> 2008       NA       NA       NA       NA       NA       NA       NA       NA #> 2009 3874.468 3887.489 3906.257 3930.825 3959.576 3991.101 4025.292 4062.564 #> 2010 4253.845 4289.213 4322.790 4353.753       NA       NA       NA       NA #>           Sep      Oct      Nov      Dec #> 2008 3835.187 3845.520 3855.656 3864.796 #> 2009 4102.100 4142.065 4180.559 4217.600 #> 2010       NA       NA       NA       NA # they can be computed using the last filtered data # e.g. to impute the first 3 missing months with last period: impute_last_obs(composite_ma, n = 3, nperiod = 1) * y #>           Jan      Feb      Mar      Apr      May      Jun      Jul      Aug #> 2008       NA       NA       NA       NA       NA 3835.187 3835.187 3835.187 #> 2009 3874.468 3887.489 3906.257 3930.825 3959.576 3991.101 4025.292 4062.564 #> 2010 4253.845 4289.213 4322.790 4353.753 4353.753 4353.753 4353.753       NA #>           Sep      Oct      Nov      Dec #> 2008 3835.187 3845.520 3855.656 3864.796 #> 2009 4102.100 4142.065 4180.559 4217.600 #> 2010       NA       NA       NA       NA # or using the filtered data of the same month in previous year impute_last_obs(composite_ma, n = 6, nperiod = 12) * y #>           Jan      Feb      Mar      Apr      May      Jun      Jul      Aug #> 2008       NA       NA 3906.257 3930.825 3959.576 3991.101 4025.292 4062.564 #> 2009 3874.468 3887.489 3906.257 3930.825 3959.576 3991.101 4025.292 4062.564 #> 2010 4253.845 4289.213 4322.790 4353.753 3959.576 3991.101 4025.292 4062.564 #>           Sep      Oct      Nov      Dec #> 2008 3835.187 3845.520 3855.656 3864.796 #> 2009 4102.100 4142.065 4180.559 4217.600 #> 2010 4102.100 4142.065       NA       NA"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/localpolynomials.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Local Polynomials Filters — localpolynomials","title":"Apply Local Polynomials Filters — localpolynomials","text":"Apply Local Polynomials Filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/localpolynomials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Local Polynomials Filters — localpolynomials","text":"","code":"localpolynomials(   x,   horizon = 6,   degree = 3,   kernel = c(\"Henderson\", \"Uniform\", \"Biweight\", \"Trapezoidal\", \"Triweight\", \"Tricube\",     \"Gaussian\", \"Triangular\", \"Parabolic\"),   endpoints = c(\"LC\", \"QL\", \"CQ\", \"CC\", \"DAF\"),   ic = 4.5,   tweight = 0,   passband = pi/12 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/localpolynomials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Local Polynomials Filters — localpolynomials","text":"x input time-series. horizon horizon (bandwidth) symmetric filter. degree degree polynomial. kernel kernel uses. endpoints methode endpoints. ic ic ratio. tweight timeliness weight. passband passband threshold.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/localpolynomials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Local Polynomials Filters — localpolynomials","text":"target signal","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/localpolynomials.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Apply Local Polynomials Filters — localpolynomials","text":"Proietti, Tommaso Alessandra Luati (2008). “Real time estimation local polynomial regression, application trend-cycle analysis”.","code":""},{"path":[]},{"path":"https://rjdemetra.github.io/rjd3filters/reference/localpolynomials.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Local Polynomials Filters — localpolynomials","text":"","code":"x <- retailsa$AllOtherGenMerchandiseStores trend <- localpolynomials(x, horizon = 6) plot(x) lines(trend, col = \"red\")"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Polynomials Filters — lp_filter","title":"Local Polynomials Filters — lp_filter","text":"Local Polynomials Filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Polynomials Filters — lp_filter","text":"","code":"lp_filter(   horizon = 6,   degree = 3,   kernel = c(\"Henderson\", \"Uniform\", \"Biweight\", \"Trapezoidal\", \"Triweight\", \"Tricube\",     \"Gaussian\", \"Triangular\", \"Parabolic\"),   endpoints = c(\"LC\", \"QL\", \"CQ\", \"CC\", \"DAF\", \"CN\"),   ic = 4.5,   tweight = 0,   passband = pi/12 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Polynomials Filters — lp_filter","text":"horizon horizon (bandwidth) symmetric filter. degree degree polynomial. kernel kernel uses. endpoints methode endpoints. ic ic ratio. tweight timeliness weight. passband passband threshold.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Polynomials Filters — lp_filter","text":"list coefficients, gain phase values object class \"rkhs_filter\", list 4 elements: \"internal\"Java object used internal functions \"filters.coef\"coefficients selected filter \"filters.gain\"gain function 0 pi (601 observations) \"filters.phase\"phase function 0 pi (601 observations)","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Polynomials Filters — lp_filter","text":"\"LC\": Linear-Constant filter \"QL\": Quadratic-Linear filter \"CQ\": Cubic-Quadratic filter \"CC\": Constant-Constant filter \"DAF\": Direct Asymmetric filter \"CN\": Cut Normalized Filter","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Local Polynomials Filters — lp_filter","text":"Proietti, Tommaso Alessandra Luati (2008). “Real time estimation local polynomial regression, application trend-cycle analysis”.","code":""},{"path":[]},{"path":"https://rjdemetra.github.io/rjd3filters/reference/lp_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Polynomials Filters — lp_filter","text":"","code":"henderson_f <- lp_filter(horizon = 6, kernel = \"Henderson\") plot_coef(henderson_f)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/moving_average.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulation of moving averages — moving_average","title":"Manipulation of moving averages — moving_average","text":"Manipulation moving averages","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/moving_average.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulation of moving averages — moving_average","text":"","code":"moving_average(   x,   lags = -length(x),   trailing_zero = FALSE,   leading_zero = FALSE )  is.moving_average(x)  is_symmetric(x)  upper_bound(x)  lower_bound(x)  mirror(x)  # S3 method for moving_average rev(x)  # S3 method for moving_average length(x)  to_seasonal(x, s)  # S4 method for moving_average show(object)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/moving_average.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manipulation of moving averages — moving_average","text":"x vector coefficients. lags integer indicating number lags moving average. trailing_zero, leading_zero boolean indicating wheter remove leading/trailing zero NA. s seasonal period to_seasonal() function. object moving_average object.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/moving_average.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Manipulation of moving averages — moving_average","text":"moving average defined set coefficient \\(\\boldsymbol \\theta=(\\theta_{-p},\\dots,\\theta_{f})'\\) time series \\(X_t\\) transformed : $$ M_{\\boldsymbol\\theta}(X_t)=\\sum_{k=-p}^{+f}\\theta_kX_{t+k}=\\left(\\sum_{k=-p}^{+f}\\theta_kB^{-k}\\right)X_{t} $$ integer \\(p\\) defined parameter lags. function to_seasonal() transforms moving average \\(\\boldsymbol \\theta\\) : $$ M_{\\boldsymbol\\theta'}(X_t)=\\sum_{k=-p}^{+f}\\theta_kX_{t+ks}=\\left(\\sum_{k=-p}^{+f}\\theta_kB^{-ks}\\right)X_{t} $$","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/moving_average.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manipulation of moving averages — moving_average","text":"","code":"y <- retailsa$AllOtherGenMerchandiseStores e1 <- moving_average(rep(1,12), lags = -6) e1 <- e1/sum(e1) e2 <- moving_average(rep(1/12, 12), lags = -5) M2X12 <- (e1 + e2)/2 coef(M2X12) #>        t-6        t-5        t-4        t-3        t-2        t-1          t  #> 0.04166667 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333  #>        t+1        t+2        t+3        t+4        t+5        t+6  #> 0.08333333 0.08333333 0.08333333 0.08333333 0.08333333 0.04166667  M3 <- moving_average(rep(1/3, 3), lags = -1) M3X3 <- M3 * M3 # M3X3 moving average applied to each month M3X3 #> [1] \"0.1111 B^2 + 0.2222 B + 0.3333 + 0.2222 F + 0.1111 F^2\" M3X3_seasonal <- to_seasonal(M3X3, 12) # M3X3_seasonal moving average applied to the global series M3X3_seasonal #> [1] \"0.1111 B^24 + 0.2222 B^12 + 0.3333 + 0.2222 F^12 + 0.1111 F^24\"  def.par <- par(no.readonly = TRUE) par(mai = c(0.5, 0.8, 0.3, 0)) layout(matrix(c(1,2), nrow = 1)) plot_gain(M3X3, main = \"M3X3 applied to each month\") plot_gain(M3X3_seasonal, main = \"M3X3 applied to the global series\")  par(def.par)  # To apply the moving average t <- y * M2X12 # Or use the filter() function: t <- filter(y, M2X12) si <- y - t s <- si * M3X3_seasonal # or equivalently: s_mm <- M3X3_seasonal * (1 - M2X12) s <- y * s_mm plot(s)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/mse.html","id":null,"dir":"Reference","previous_headings":"","what":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","title":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","text":"Accuracy/smoothness/timeliness criteria spectral decomposition","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/mse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","text":"","code":"mse(aweights, sweights, density = c(\"uniform\", \"rw\"), passband = pi/6, ...)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/mse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","text":"aweights moving_average object weights asymmetric filter (-n m). sweights moving_average object weights symmetric filter (0 n -n n). density hypothesis spectral density: \"uniform\" (= white woise, default)  \"rw\" (= random walk). passband passband threshold. ... unused arguments.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/mse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","text":"criteria","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/mse.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","text":"Wildi, Marc McElroy, Tucker (2019). “trilemma accuracy, timeliness smoothness real-time signal extraction”. : International Journal Forecasting 35.3, pp. 1072–1084.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/mse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Accuracy/smoothness/timeliness criteria through spectral decomposition — mse","text":"","code":"filter <- lp_filter(horizon = 6, kernel = \"Henderson\", endpoints = \"LC\") sweights <- filter[, \"q=6\"] aweights <- filter[, \"q=0\"] mse(aweights, sweights) #>    accuracy  smoothness  timeliness    residual  #> 0.008306348 0.449956378 0.061789932 0.299548665  # Or to compute directly the criteria on all asymmetric filters: mse(filter) #>                      q=6          q=5          q=4          q=3          q=2 #> accuracy    6.024615e-31 3.003396e-04 0.0022730023 0.0036954760 0.0010393071 #> smoothness  2.495366e-32 1.387928e-03 0.0049316361 0.0056152618 0.0181979732 #> timeliness  3.783119e-31 5.977841e-05 0.0001510595 0.0001125956 0.0007184473 #> residual   -4.091914e-31 1.363420e-03 0.0051414956 0.0049053853 0.0144907081 #>                     q=1         q=0 #> accuracy   0.0009371065 0.008306348 #> smoothness 0.1382592159 0.449956378 #> timeliness 0.0105376169 0.061789932 #> residual   0.0756650916 0.299548665"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/plot_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots filters properties — plot_filters","title":"Plots filters properties — plot_filters","text":"Functions plot coefficients, gain phase functions.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/plot_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots filters properties — plot_filters","text":"","code":"plot_coef(x, nxlab = 7, add = FALSE, ...)  # S3 method for default plot_coef(   x,   nxlab = 7,   add = FALSE,   zero_as_na = TRUE,   q = 0,   legend = FALSE,   legend.pos = \"topright\",   ... )  # S3 method for moving_average plot_coef(x, nxlab = 7, add = FALSE, ...)  # S3 method for finite_filters plot_coef(   x,   nxlab = 7,   add = FALSE,   zero_as_na = TRUE,   q = 0,   legend = length(q) > 1,   legend.pos = \"topright\",   ... )  plot_gain(x, nxlab = 7, add = FALSE, xlim = c(0, pi), ...)  # S3 method for moving_average plot_gain(x, nxlab = 7, add = FALSE, xlim = c(0, pi), ...)  # S3 method for finite_filters plot_gain(   x,   nxlab = 7,   add = FALSE,   xlim = c(0, pi),   q = 0,   legend = length(q) > 1,   legend.pos = \"topright\",   n = 101,   ... )  plot_phase(x, nxlab = 7, add = FALSE, xlim = c(0, pi), normalized = FALSE, ...)  # S3 method for moving_average plot_phase(x, nxlab = 7, add = FALSE, xlim = c(0, pi), normalized = FALSE, ...)  # S3 method for finite_filters plot_phase(   x,   nxlab = 7,   add = FALSE,   xlim = c(0, pi),   normalized = FALSE,   q = 0,   legend = length(q) > 1,   legend.pos = \"topright\",   n = 101,   ... )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/plot_filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots filters properties — plot_filters","text":"x coefficients, gain phase. nxlab number xlab. add boolean indicating new plot added previous one. ... arguments matplot. zero_as_na boolean indicating trailing zero coefficients plotted (FALSE) removed (TRUE). q q. legend boolean indicating legend printed. legend.pos position legend. xlim vector containing x limits. n number points used plot functions. normalized boolean indicatif phase function normalized frequency.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/plot_filters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots filters properties — plot_filters","text":"","code":"filter <- lp_filter(6, endpoints = \"DAF\", kernel = \"Henderson\") plot_coef(filter, q = c(0,3), legend = TRUE)  plot_gain(filter, q = c(0,3), legend = TRUE)  plot_phase(filter, q = c(0,3), legend = TRUE)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/retailsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Seasonally Adjusted Retail Sales — retailsa","title":"Seasonally Adjusted Retail Sales — retailsa","text":"dataset containing monthly seasonally adjusted retailed sales","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/retailsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Seasonally Adjusted Retail Sales — retailsa","text":"","code":"retailsa"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/retailsa.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Seasonally Adjusted Retail Sales — retailsa","text":"list ts objects january 1992 december 2010.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","title":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","text":"Estimation filter using Reproducing Kernel Hilbert Space (RKHS)","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","text":"","code":"rkhs_filter(   horizon = 6,   degree = 2,   kernel = c(\"BiWeight\", \"Henderson\", \"Epanechnikov\", \"Triangular\", \"Uniform\",     \"TriWeight\"),   asymmetricCriterion = c(\"Timeliness\", \"FrequencyResponse\", \"Accuracy\", \"Smoothness\",     \"Undefined\"),   density = c(\"uniform\", \"rw\"),   passband = 2 * pi/12,   optimalbw = TRUE,   optimal.minBandwidth = horizon,   optimal.maxBandwidth = 3 * horizon,   bandwidth = horizon + 1 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","text":"horizon horizon (bandwidth) symmetric filter. degree degree polynomial. kernel kernel uses. asymmetricCriterion criteria used compute optimal bandwidth. \"Undefined\", \\(m+1\\) used. density hypothesis spectral density: \"uniform\" (= white woise, default)  \"rw\" (= random walk). passband passband threshold. optimalbw boolean indicating bandwith choosen optimisation (optimal.minBandwidth optimal.minBandwidth using criteria asymmetricCriterion). optimalbw = FALSE bandwith specified bandwidth  used. optimal.minBandwidth, optimal.maxBandwidth range used optimal bandwith selection. bandwidth bandwidth use optimalbw = FALSE.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","text":"object class \"rkhs_filter\", list 4 elements: \"internal\"Java object used internal functions \"filters.coef\"coefficients selected filter \"filters.gain\"gain function 0 pi (601 observations) \"filters.phase\"phase function 0 pi (601 observations)","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_filter.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","text":"Dagum, Estela Bee Silvia Bianconcini (2008). “Henderson Smoother Reproducing Kernel Hilbert Space”. : Journal Business & Economic Statistics 26, pp. 536–545. URL: https://ideas.repec.org//bes/jnlbes/v26y2008p536-545.html.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_filter","text":"","code":"rkhs <- rkhs_filter(horizon = 6, asymmetricCriterion = \"Timeliness\") plot_coef(rkhs)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Get RKHS kernel function — rkhs_kernel","title":"Get RKHS kernel function — rkhs_kernel","text":"Get RKHS kernel function","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get RKHS kernel function — rkhs_kernel","text":"","code":"rkhs_kernel(   kernel = c(\"Biweight\", \"Henderson\", \"Epanechnikov\", \"Triangular\", \"Uniform\",     \"Triweight\"),   degree = 2,   horizon = 6 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get RKHS kernel function — rkhs_kernel","text":"kernel kernel uses. degree degree polynomial. horizon horizon (bandwidth) symmetric filter.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimal_bw.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Bandwith of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimal_bw","title":"Optimal Bandwith of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimal_bw","text":"Function export optimal bandwidths used Reproducing Kernel Hilbert Space (RKHS) filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimal_bw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal Bandwith of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimal_bw","text":"","code":"rkhs_optimal_bw(   horizon = 6,   degree = 2,   kernel = c(\"Biweight\", \"Henderson\", \"Epanechnikov\", \"Triangular\", \"Uniform\",     \"Triweight\"),   asymmetricCriterion = c(\"Timeliness\", \"FrequencyResponse\", \"Accuracy\", \"Smoothness\"),   density = c(\"uniform\", \"rw\"),   passband = 2 * pi/12,   optimal.minBandwidth = horizon,   optimal.maxBandwidth = 3 * horizon )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimal_bw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Bandwith of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimal_bw","text":"horizon horizon (bandwidth) symmetric filter. degree degree polynomial. kernel kernel uses. asymmetricCriterion criteria used compute optimal bandwidth. \"Undefined\", \\(m+1\\) used. density hypothesis spectral density: \"uniform\" (= white woise, default)  \"rw\" (= random walk). passband passband threshold. optimal.minBandwidth, optimal.maxBandwidth range used optimal bandwith selection.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimal_bw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Bandwith of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimal_bw","text":"","code":"rkhs_optimal_bw(asymmetricCriterion = \"Timeliness\") #>    q=0    q=1    q=2    q=3    q=4    q=5  #> 6.0000 6.0000 6.3875 8.1500 9.3500 6.0000  rkhs_optimal_bw(asymmetricCriterion = \"Timeliness\", optimal.minBandwidth = 6.2) #>       q=0       q=1       q=2       q=3       q=4       q=5  #>  6.200000  6.200000  6.384375  8.148229  9.352812 10.391458"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimization_fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization Function of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimization_fun","title":"Optimization Function of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimization_fun","text":"Export function used compute optimal bandwidth Reproducing Kernel Hilbert Space (RKHS) filters","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimization_fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization Function of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimization_fun","text":"","code":"rkhs_optimization_fun(   horizon = 6,   leads = 0,   degree = 2,   kernel = c(\"Biweight\", \"Henderson\", \"Epanechnikov\", \"Triangular\", \"Uniform\",     \"Triweight\"),   asymmetricCriterion = c(\"Timeliness\", \"FrequencyResponse\", \"Accuracy\", \"Smoothness\"),   density = c(\"uniform\", \"rw\"),   passband = 2 * pi/12 )"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimization_fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization Function of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimization_fun","text":"horizon horizon (bandwidth) symmetric filter. leads Leads filter (positive 0). degree degree polynomial. kernel kernel uses. asymmetricCriterion criteria used compute optimal bandwidth. \"Undefined\", \\(m+1\\) used. density hypothesis spectral density: \"uniform\" (= white woise, default)  \"rw\" (= random walk). passband passband threshold.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/rkhs_optimization_fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimization Function of Reproducing Kernel Hilbert Space (RKHS) Filters — rkhs_optimization_fun","text":"","code":"plot(rkhs_optimization_fun(horizon = 6, leads = 0,degree = 3, asymmetricCriterion = \"Timeliness\"),      5.5, 6*3, ylab = \"Timeliness\",      main = \"6X0 filter\")  plot(rkhs_optimization_fun(horizon = 6, leads = 1,degree = 3, asymmetricCriterion = \"Timeliness\"),      5.5, 6*3, ylab = \"Timeliness\",      main = \"6X1 filter\")  plot(rkhs_optimization_fun(horizon = 6, leads = 2,degree = 3, asymmetricCriterion = \"Timeliness\"),      5.5, 6*3, ylab = \"Timeliness\",      main = \"6X2 filter\")  plot(rkhs_optimization_fun(horizon = 6, leads = 3,degree = 3, asymmetricCriterion = \"Timeliness\"),      5.5, 6*3, ylab = \"Timeliness\",      main = \"6X3 filter\")  plot(rkhs_optimization_fun(horizon = 6, leads = 4,degree = 3, asymmetricCriterion = \"Timeliness\"),      5.5, 6*3, ylab = \"Timeliness\",      main = \"6X4 filter\")  plot(rkhs_optimization_fun(horizon = 6, leads = 5,degree = 3, asymmetricCriterion = \"Timeliness\"),      5.5, 6*3, ylab = \"Timeliness\",      main = \"6X5 filter\")"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/simple_ma.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple Moving Average — simple_ma","title":"Simple Moving Average — simple_ma","text":"simple moving average moving average whose coefficients equal whose sum 1","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/simple_ma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple Moving Average — simple_ma","text":"","code":"simple_ma(order, lags = -trunc((order - 1)/2))"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/simple_ma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple Moving Average — simple_ma","text":"order number terms moving_average lags integer indicating number lags moving average.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/simple_ma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple Moving Average — simple_ma","text":"","code":"# The M2X12 moving average is computed as (simple_ma(12, -6) + simple_ma(12, -5)) / 2 #> [1] \"0.0417 B^6 + 0.0833 B^5 + 0.0833 B^4 + 0.0833 B^3 + 0.0833 B^2 + 0.0833 B + 0.0833 + 0.0833 F + 0.0833 F^2 + 0.0833 F^3 + 0.0833 F^4 + 0.0833 F^5 + 0.0417 F^6\" # The M3X3 moving average is computed as simple_ma(3, -1) ^ 2 #> [1] \"0.1111 B^2 + 0.2222 B + 0.3333 + 0.2222 F + 0.1111 F^2\" # The M3X5 moving average is computed as simple_ma(3, -1) * simple_ma(5, -2) #> [1] \"0.0667 B^3 + 0.1333 B^2 + 0.2000 B + 0.2000 + 0.2000 F + 0.1333 F^2 + 0.0667 F^3\""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/var_estimator.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance Estimator — var_estimator","title":"Variance Estimator — var_estimator","text":"Variance Estimator","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/var_estimator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance Estimator — var_estimator","text":"","code":"var_estimator(x, coef, ...)"},{"path":"https://rjdemetra.github.io/rjd3filters/reference/var_estimator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance Estimator — var_estimator","text":"x input time series. coef vector coefficients moving-average (moving_average()). ... arguments passed function moving_average() convert coef \"moving_average\" object.","code":""},{"path":"https://rjdemetra.github.io/rjd3filters/reference/var_estimator.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Variance Estimator — var_estimator","text":"$$ \\hat\\sigma^2=\\frac{1}{n-2h}\\sum_{t=h+1}^{n-h}\\frac{(y_t-\\hat \\mu_t)^2}{1-2w_0^2+\\sum w_i^2} $$","code":""}]
